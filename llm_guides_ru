# Гайд 1: Общие принципы работы с LLM

## Философия взаимодействия

**Принцип 1: LLM - это конструктор, не архитектор**
- LLM отлично строит по чертежу, но плохо создает архитектуру
- Ты определяешь ЧТО и КАК, LLM пишет код
- Чем точнее чертеж, тем лучше результат

**Принцип 2: Итеративность важнее полноты**
- Лучше 10 маленьких шагов, чем 1 большой прыжок
- Каждый шаг = понимание + контроль
- Можешь менять направление после каждого шага

**Принцип 3: Конкретика побеждает абстракцию**
- "красивая кнопка" = 100 вариантов
- "синяя кнопка #3B82F6, rounded-lg, padding 12px 24px" = 1 вариант
- Чем меньше вариантов, тем быстрее результат

**Принцип 4: Контекст решает все**
- Технологический стек
- Существующий код (если расширяешь)
- Ограничения и НЕ-требования
- Формат ответа

## Ментальная модель: Диалог с джуниором

Представь что LLM - это очень быстрый, но неопытный разработчик:

**Он умеет:**
- Быстро писать типовой код
- Следовать четким инструкциям
- Искать паттерны в примерах
- Адаптировать существующий код

**Он НЕ умеет:**
- Понимать бизнес-контекст без объяснений
- Предугадывать твои предпочтения
- Видеть общую картину большого проекта
- Принимать архитектурные решения

**Поэтому:**
- Давай конкретные задачи
- Объясняй контекст
- Показывай примеры
- Проверяй результат
- Направляй, если уходит не туда

## Когда что использовать

### LLM идеален для:

**Генерация с нуля:**
- Новые компоненты по спецификации
- CRUD endpoints
- Утилитарные функции
- Типовые формы
- Базовые API клиенты

**Трансформация:**
- Рефакторинг небольших функций
- Изменение стилей компонента
- Добавление новых полей в форму
- Обновление API response формата

**Объяснение:**
- Как работает чужой код
- Почему возникает ошибка
- Варианты решения проблемы

### LLM НЕ идеален для:

**Архитектура:**
- Выбор между подходами
- Структура всего проекта
- Паттерны для масштабирования

**Критичный код:**
- Безопасность (auth, payments)
- Сложные алгоритмы
- Performance-критичные участки

**Интеграция:**
- Понимание как части системы взаимодействуют
- Debuging межсервисного взаимодействия
- Полный e2e flow

## Признаки правильной задачи для LLM

**✅ Задача готова для LLM если:**
- Ты можешь описать результат в 3-5 предложениях
- Понятен вход (данные/параметры) и выход (UI/response)
- Есть один четкий критерий успеха
- Ты знаешь как проверить что работает правильно
- Можешь нарисовать блок-схему на салфетке за 2 минуты

**❌ Задача НЕ готова если:**
- "Сделай что-то типа как в X, но по-другому"
- Ты сам не понимаешь все требования
- Зависит от кучи других частей системы
- Нужно "посмотреть как лучше"
- Ты не знаешь что должно получиться

## Cycle работы

```
1. ПЛАНИРОВАНИЕ (30% времени)
   ↓
2. ЗАПРОС К LLM (5% времени)
   ↓
3. ПРОВЕРКА КОДА (20% времени)
   ↓
4. ТЕСТИРОВАНИЕ (25% времени)
   ↓
5. ИТЕРАЦИЯ или СЛЕДУЮЩАЯ ЗАДАЧА (20% времени)
```

Если планирование занимает меньше времени - ты недодумал.
Если запросов больше 3 на одну задачу - задача была слишком большой.

---

# Гайд 2: Препроцессинг - Подготовка перед запросом

## Шаг 1: Декомпозиция - понимание масштаба

### Метод "Слои луковицы"

Разбери задачу на слои от самого простого к сложному:

**Пример: "Форма регистрации с проверкой email"**

```
Слой 1 (Core): HTML форма с полями email, password
Слой 2 (Basic UX): Стили, layout, responsive
Слой 3 (Validation): Валидация форматов, ошибки
Слой 4 (Integration): Отправка на API, loading состояния
Слой 5 (Polish): Анимации, успешная регистрация, edge cases
```

**Правило**: Отдавай LLM максимум 2 слоя за раз.

### Метод "Вопросы на понимание"

Перед любой задачей ответь себе:

1. **Что пользователь видит?** (UI/Output)
2. **Что пользователь делает?** (Interactions)
3. **Откуда данные?** (Input/Source)
4. **Куда данные?** (Output/Destination)
5. **Что может пойти не так?** (Error cases)

Если на любой вопрос ответ "не знаю" - задача не готова.

### Метод "Таймбоксинг"

**Оцени: сколько времени займет объяснить это другому разработчику?**

- < 5 минут → Простая задача, можно отдавать LLM
- 5-15 минут → Средняя, разбей на 2-3 части
- 15-30 минут → Сложная, разбей на 5+ частей
- > 30 минут → Это не задача, это проект. Декомпозируй глубже.

## Шаг 2: Оценка - определение границ

### Фронтенд: правило "трех компонентов"

Открой любой UI фреймворк (Material-UI, Ant Design). Посмотри на их компоненты:

**Простые (1 запрос к LLM):**
- Button, Input, Card, Badge, Alert
- Обычно это 50-150 строк кода
- 1-3 props
- Без сложной логики

**Средние (2-3 запроса к LLM):**
- Form, Modal, Table (без пагинации), Dropdown
- 150-400 строк кода
- 5-10 props
- State management

**Сложные (5+ запросов к LLM):**
- DataGrid, Chart, Rich Text Editor, File Upload with preview
- 400+ строк кода
- Множество функций
- Обязательно разбивать

**Твоя задача сложнее самого сложного компонента в UI библиотеке? Точно нужно делить.**

### Бэкенд: правило "REST endpoint"

**1 endpoint = 1 задача для LLM** (обычно)

**Простой endpoint (1 запрос):**
```
GET /users/:id
- Получить по ID
- Вернуть 404 если нет
- Вернуть JSON
```

**Средний endpoint (2 запроса):**
```
POST /users
- Принять данные
- Валидировать
- Сохранить в БД
- Вернуть созданный объект или ошибки
```

**Сложный endpoint (разбить на части):**
```
POST /orders/checkout
- Проверить корзину
- Рассчитать цену
- Применить промокод
- Списать со склада
- Создать заказ
- Отправить email
- Вернуть детали заказа
```
→ Разбей на: валидация корзины, расчет цены, создание заказа, уведомления

### Количественные метрики

**Фронтенд - считай элементы:**
- Интерактивных элементов (кнопки, инпуты): 1-5 за раз
- JSX элементов верхнего уровня: до 10
- useState вызовов: до 3
- useEffect хуков: до 2
- Props в компоненте: до 7

**Бэкенд - считай операции:**
- Database queries: до 3 в одном handler
- Валидационных правил: до 5-7
- If-else веток: до 5
- Функций в одном файле: до 4

**Превышаешь эти числа? → Делим задачу.**

## Шаг 3: Фрагментация - разбиение задачи

### Стратегия "Вертикальные слайсы"

**❌ Плохо (горизонтальная нарезка):**
```
1. Сделай все компоненты
2. Сделай всю логику
3. Подключи к API
```

**✅ Хорошо (вертикальная нарезка):**
```
1. Компонент А + его логика + его API
2. Компонент Б + его логика + его API
3. Интеграция А и Б
```

Каждый слайс = рабочая функция end-to-end.

### Матрица зависимостей

Нарисуй простую таблицу:

```
Компонент/Функция | Зависит от | Используется в
------------------|------------|----------------
UserCard          | User type  | UserList, Dashboard
UserList          | UserCard   | Dashboard
Dashboard         | API client | App
API client        | -          | Везде
```

**Порядок разработки = снизу вверх:**
1. API client (ни от чего не зависит)
2. User type (не зависит)
3. UserCard (зависит от User type)
4. UserList (зависит от UserCard)
5. Dashboard (зависит от всех)

**Правило**: Сначала генерим то, от чего зависят другие.

### Чек-лист фрагментации

Для каждой части задачи:

- [ ] Может работать независимо от остальных?
- [ ] Можно протестировать изолированно?
- [ ] Понятен input и output?
- [ ] Один файл или максимум 2?
- [ ] Укладывается в твое понимание (можешь пересказать)?

Если хоть один "нет" - дели дальше.

## Шаг 4: Подготовка материалов

### Технический контекст (обязательно)

Создай шаблон для своего проекта и используй каждый раз:

```
Stack: React 18 + TypeScript + Vite
Styling: Tailwind CSS
State: Zustand
API: Axios
Form: React Hook Form + Zod
```

### Сбор референсов

**Для UI задач:**

1. **Найди похожий компонент:**
   - В UI библиотеке (shadcn/ui, MUI)
   - На сайтах (dribbble, mobbin для мобилок)
   - В своем проекте (что уже работает)

2. **Сделай скриншот или опиши:**
   - "Как в MUI Button, но цвета другие"
   - "Как Gmail inbox, но без меток"

3. **Определи отличия:**
   - Что добавить
   - Что убрать
   - Что изменить

**Для логики/API:**

1. **Найди похожий endpoint:**
   - В документации API
   - В другом сервисе проекта
   - В OpenAPI/Swagger примерах

2. **Скопируй структуру:**
   - Request body пример
   - Response пример
   - Error responses

### Подготовка скриншотов (если используешь)

**Чек-лист качественного скриншота:**

- [ ] Разрешение минимум 1080p
- [ ] Только целевой компонент (обрежь остальное)
- [ ] Четкие границы (не размыто)
- [ ] Все тексты читаемы
- [ ] Все элементы полностью видны
- [ ] Один компонент = один скриншот

**Если компонент сложный:**

Сделай несколько скриншотов:
- Общий вид
- Каждое состояние (hover, active, disabled)
- Каждый вариант (если есть размеры/темы)

**Аннотация скриншота:**

Используй любой инструмент (даже Paint):
- Красными рамками - что важно
- Стрелками - связи элементов
- Текстом - названия частей
- Размерами - если критично

### Данные для работы

**Подготовь примеры данных:**

```typescript
const exampleUser = {
  id: "123",
  name: "John Doe",
  email: "john@example.com",
  role: "admin"
}
```

**Для списков - дай 3-5 объектов:**
- Типичный случай
- Edge case (длинное имя, нет фото, и т.д.)
- Минимальный (только обязательные поля)

**Для API:**
- Успешный response
- Ошибка валидации
- Ошибка 404
- Ошибка 500

## Шаг 5: Формулировка критериев успеха

### Определи "Definition of Done"

Напиши список что должно работать:

**Пример для формы:**
```
✓ Все поля рендерятся
✓ Валидация показывается при blur
✓ Submit кнопка disabled если форма невалидна
✓ При submit вызывается onSubmit с правильными данными
✓ Loading состояние во время отправки
✓ Ошибки API показываются пользователю
```

### Подготовь тест-кейсы

Даже мысленно:

1. **Happy path**: Что должно работать в идеале
2. **Edge cases**: Пустые данные, длинные строки, специальные символы
3. **Error handling**: Что если API не отвечает, что если валидация не прошла

**Если не можешь написать тест-кейсы - задача не готова.**

## Итоговый чек-лист перед запросом

Пройдись по этому списку перед каждым промптом:

- [ ] Я могу описать задачу в 3 предложениях
- [ ] Я знаю какой код получу (примерно сколько файлов и строк)
- [ ] Я подготовил технический контекст
- [ ] Я знаю откуда данные и куда они идут
- [ ] Я могу проверить результат за 5 минут
- [ ] У меня есть референс или четкое описание UI
- [ ] Я знаю что делать если это не сработает (план Б)
- [ ] Эта часть не зависит от недоделанных частей

**Если хоть один пункт "нет" - возвращайся к планированию.**

---

# Гайд 3: Составление промпта - Эффективная коммуникация

## Структура идеального промпта

### Шаблон промпта (копируй и адаптируй)

```markdown
КОНТЕКСТ:
[Технический стек и окружение]

ЗАДАЧА:
[Одно предложение - что создать]

ТРЕБОВАНИЯ:
[Нумерованный список конкретных требований]

ДАННЫЕ:
[Структура входящих/исходящих данных]

ДЕТАЛИ:
[Специфичные детали: цвета, размеры, поведение]

НЕ ДЕЛАТЬ:
[Что точно не нужно]

ФОРМАТ ОТВЕТА:
[Как организовать код]
```

## Компонент 1: Контекст

### Что включать ВСЕГДА

**Минимальный технический контекст:**

Фронтенд:
```
React 18 + TypeScript
Tailwind CSS
```

Бэкенд:
```
Node.js + Express + TypeScript
PostgreSQL + Prisma
```

### Расширенный контекст (когда нужен)

**Добавляй если используешь:**

State management:
```
State: Zustand (глобальный), useState (локальный)
```

Специфичные библиотеки:
```
Forms: React Hook Form + Zod валидация
```

Архитектурные паттерны:
```
Архитектура: Feature-based структура папок
```

Существующий код:
```
Базируется на: компоненте Card из /components/ui/card.tsx
```

### Примеры контекста

**Плохо:**
```
Я использую React
```

**Хорошо:**
```
Stack: React 18 + TypeScript + Vite
UI: Tailwind CSS (v3)
Icons: lucide-react
```

**Отлично:**
```
Stack: React 18 + TypeScript + Vite
UI: Tailwind CSS (v3) + следую существующему дизайну с primary: #3B82F6
Icons: lucide-react
State: props + локальный useState (без Redux)
Naming: camelCase для переменных, PascalCase для компонентов
```

## Компонент 2: Задача

### Формула одного предложения

```
Создать [ТИП] который [ДЕЙСТВИЕ] для [ЦЕЛЬ]
```

**Примеры:**

Фронтенд:
```
Создать React компонент который отображает карточку пользователя с возможностью редактирования
```

Бэкенд:
```
Создать POST endpoint который регистрирует нового пользователя и возвращает JWT token
```

### Избегай расплывчатости

**❌ Плохо:**
- "Сделай форму"
- "Нужен API для юзеров"
- "Компонент для отображения данных"

**✅ Хорошо:**
- "Форма логина с email и паролем"
- "GET endpoint для получения списка пользователей с фильтрацией"
- "Таблица с 5 колонками и сортировкой по клику"

## Компонент 3: Требования

### Принцип MECE (Mutually Exclusive, Collectively Exhaustive)

Каждое требование должно быть:
- **Конкретным** (измеримым)
- **Независимым** (не перекрывается с другими)
- **Полным** (вместе покрывают все)

### Структура требований

**Категории требований:**

1. **Функциональные** (что делает)
2. **UI/UX** (как выглядит и ведет себя)
3. **Данные** (что принимает/возвращает)
4. **Валидация** (какие правила)
5. **Обработка ошибок** (что делать при проблемах)

### Примеры требований

**Фронтенд - Форма:**

```markdown
ТРЕБОВАНИЯ:
1. Поля: email (text input), password (password input), remember me (checkbox)
2. Валидация email: проверка формата, показ ошибки под полем
3. Валидация password: минимум 8 символов, показ ошибки под полем
4. Submit кнопка: disabled если форма невалидна, показывает "Loading..." во время отправки
5. При успехе: вызвать onSuccess callback с данными {email, password, rememberMe}
6. При ошибке: показать красный Alert над формой с текстом ошибки
```

**Бэкенд - API Endpoint:**

```markdown
ТРЕБОВАНИЯ:
1. Route: POST /api/auth/register
2. Request body: {email: string, password: string, name: string}
3. Валидация: email формат, password минимум 8 символов, name обязательное
4. Проверка: email должен быть уникальным в БД
5. При успехе: создать пользователя, вернуть 201 {userId, token, name}
6. При дубликате email: вернуть 409 {error: "Email already exists"}
7. При невалидных данных: вернуть 400 {errors: {field: "message"}}
```

### Правило "7±2"

Человек держит в голове 5-9 пунктов. 

**Если требований больше 9 - задача слишком большая.**

Раздели на подзадачи:
```
Задача А: Требования 1-5
Задача Б: Требования 6-9
```

## Компонент 4: Данные

### Типы и форматы

**Всегда показывай структуру данных:**

TypeScript:
```typescript
interface User {
  id: string;
  name: string;
  email: string;
  avatar?: string;
  role: 'admin' | 'user';
}
```

JavaScript:
```javascript
const exampleUser = {
  id: "abc123",
  name: "John Doe",
  email: "john@example.com",
  avatar: "https://...",
  role: "user"
}
```

### Props для компонентов

**Укажи все props:**

```markdown
PROPS:
- user: User (обязательный) - данные пользователя для отображения
- onEdit: (userId: string) => void (опциональный) - callback при клике на Edit
- isEditable: boolean (опциональный, default: false) - показывать ли кнопку Edit
```

### API request/response

**Покажи примеры:**

```markdown
REQUEST:
POST /api/users
{
  "name": "John Doe",
  "email": "john@example.com"
}

RESPONSE (успех):
201 Created
{
  "id": "user_abc123",
  "name": "John Doe",
  "email": "john@example.com",
  "createdAt": "2025-10-26T10:00:00Z"
}

RESPONSE (ошибка):
400 Bad Request
{
  "error": "Validation failed",
  "details": {
    "email": "Invalid email format"
  }
}
```

## Компонент 5: Детали

### UI/UX специфика

**Цвета (обязательно указывать):**
```
Primary: #3B82F6 (синий)
Success: #10B981 (зеленый)
Error: #EF4444 (красный)
Background: #F9FAFB (светло-серый)
```

**Размеры и отступы:**
```
Padding: 16px (внутри карточки)
Gap между элементами: 12px
Border radius: 8px
Font size: 14px (обычный текст), 18px (заголовки)
```

**Responsive:**
```
Mobile (< 768px): 1 колонка
Tablet (768px - 1024px): 2 колонки
Desktop (> 1024px): 3 колонки
```

### Поведение

**Интерактивность:**
```
Hover: кнопка меняет цвет на #2563EB (темнее синего)
Click: ripple эффект
Focus: синяя обводка 2px
Disabled: opacity 0.5, cursor not-allowed
```

**Анимации (если нужны):**
```
Появление: fade-in 200ms
Закрытие: fade-out 150ms
Loading: spinner rotation
```

### Состояния

**Перечисли все состояния:**
```
СОСТОЯНИЯ:
- Initial: форма пустая, submit disabled
- Filling: пользователь вводит данные, валидация при blur
- Submitting: loading spinner, все поля disabled
- Success: показать зеленый чекмарк, форма очищается через 2 сек
- Error: красный alert, поля остаются заполненными
```

## Компонент 6: Что НЕ делать

### Критически важно!

LLM часто добавляет "лишнее" если не сказать явно что не нужно.

**Типичные "НЕ делать":**

Фронтенд:
```
НЕ ДЕЛАТЬ:
- Не добавляй react-router навигацию (это будет в родителе)
- Не делай API вызов внутри компонента (передается через props)
- Не добавляй анимации (сделаю позже)
- Не используй Context API (будет useState)
```

Бэкенд:
```
НЕ ДЕЛАТЬ:
- Не добавляй JWT middleware (уже есть в router)
- Не создавай схему БД (уже есть в schema.prisma)
- Не добавляй logging (есть глобальный logger)
- Не делай хеширование пароля (есть в auth service)
```

### Ограничения библиотек

```
НЕ ИСПОЛЬЗУЙ:
- React Query (в проекте нет)
- Lodash (используй нативный JS)
- Moment.js (используй date-fns)
```

## Компонент 7: Формат ответа

### Структура кода

**Укажи как организовать:**

Один файл:
```
ФОРМАТ:
Один файл: UserCard.tsx с экспортом по умолчанию
```

Несколько файлов:
```
ФОРМАТ:
/components/UserCard/
  ├── UserCard.tsx (главный компонент)
  ├── UserCardHeader.tsx (подкомпонент)
  ├── types.ts (типы)
  └── index.ts (реэкспорт)
```

API структура:
```
ФОРМАТ:
/api/users/
  ├── controller.ts (обработчики запросов)
  ├── service.ts (бизнес-логика)
  ├── validation.ts (схемы валидации)
  └── types.ts (типы)
```

### Naming conventions

```
NAMING:
- Файлы компонентов: PascalCase (UserCard.tsx)
- Файлы утилит: camelCase (formatDate.ts)
- Переменные: camelCase
- Константы: UPPER_SNAKE_CASE
- Интерфейсы: I prefix (IUserCardProps)
```

## Полные примеры промптов

### Пример 1: Фронтенд компонент

```markdown
КОНТЕКСТ:
React 18 + TypeScript
Tailwind CSS (v3)
lucide-react для иконок

ЗАДАЧА:
Создать компонент карточки пользователя с кнопками Edit и Delete

ТРЕБОВАНИЯ:
1. Отображать avatar (или placeholder если нет), имя, email, роль
2. Кнопка Edit (иконка Pencil): видна только если isEditable=true
3. Кнопка Delete (иконка Trash2): показывает confirm перед удалением
4. Клик на avatar или имя: вызывает onUserClick с userId
5. Роль admin показывается с золотой badge, user с серой
6. Hover: легкая тень и подъем карточки

ДАННЫЕ:
interface UserCardProps {
  user: {
    id: string;
    name: string;
    email: string;
    avatar?: string;
    role: 'admin' | 'user';
  };
  isEditable?: boolean;
  onEdit?: (userId: string) => void;
  onDelete?: (userId: string) => void;
  onUserClick?: (userId: string) => void;
}

ДЕТАЛИ:
Цвета:
- Background: white
- Border: #E5E7EB (серый)
- Admin badge: #FBBF24 (золотой)
- User badge: #9CA3AF (серый)

Размеры:
- Card width: 320px
- Padding: 16px
- Border radius: 12px
- Avatar: 64x64px круглый
- Gap между элементами: 12px

НЕ ДЕЛАТЬ:
- Не добавляй React Router Link
- Не делай API вызовов
- Не добавляй анимации

ФОРМАТ:
Один файл UserCard.tsx с default export
```

### Пример 2: Бэкенд endpoint

```markdown
КОНТЕКСТ:
Node.js + Express + TypeScript
PostgreSQL + Prisma ORM
Zod для валидации

ЗАДАЧА:
Создать POST endpoint для создания нового пользователя

ТРЕБОВАНИЯ:
1. Route: POST /api/users
2. Валидация body: name (мин 2 символа), email (формат), password (мин 8 символов)
3. Проверка: email должен быть уникальным
4. Хеширование password с bcrypt (10 раундов)
5. Создание записи в БД с полями: id (auto), name, email, hashedPassword, createdAt (auto)
6. Response 201: userId, name, email (БЕЗ пароля)
7. Response 400: валидация не прошла с деталями ошибок
8. Response 409: email уже существует

ДАННЫЕ:
Request:
{
  "name": "John Doe",
  "email": "john@example.com",
  "password": "securepass123"
}

Response (201):
{
  "id": "user_abc123",
  "name": "John Doe",
  "email": "john@example.com",
  "createdAt": "2025-10-26T10:00:00Z"
}

Response (400):
{
  "error": "Validation failed",
  "details": {
    "email": "Invalid email format",
    "password": "Password must be at least 8 characters"
  }
}

Response (409):
{
  "error": "Email already exists"
}

ДЕТАЛИ:
Prisma схема:
model User {
  id        String   @id @default(cuid())
  name      String
  email     String   @unique
  password  String
  createdAt DateTime @default(now())
}

НЕ ДЕЛАТЬ:
- Не добавляй JWT токен (будет в отдельном endpoint)
- Не добавляй email верификацию (пока не нужно)
- Не добавляй middleware авторизации (это публичный endpoint)

ФОРМАТ:
/api/users/
  ├── create.controller.ts (Express handler)
  ├── create.service.ts (бизнес-логика)
  └── validation.ts (Zod схемы)
```

### Пример 3: Утилитарная функция

```markdown
КОНТЕКСТ:
TypeScript
date-fns библиотека доступна

ЗАДАЧА:
Создать функцию для форматирования дат в человекочитаемый формат

ТРЕБОВАНИЯ:
1. Принимает Date или ISO string
2. Если дата сегодня: "Today at 14:30"
3. Если вчера: "Yesterday at 14:30"
4. Если в течение недели: "Monday at 14:30"
5. Если старше недели: "Oct 15, 2025"
6. Если другой год: "Oct 15, 2024"
7. Обработка невалидных дат: return "Invalid date"

ДАННЫЕ:
function formatRelativeDate(date: Date | string): string

Примеры:
formatRelativeDate(new Date()) → "Today at 14:30"
formatRelativeDate("2025-10-25T10:00:00Z") → "Yesterday at 10:00"
formatRelativeDate("2025-10-20T10:00:00Z") → "Sunday at 10:00"
formatRelativeDate("2025-09-15T10:00:00Z") → "Sep 15, 2025"
formatRelativeDate("invalid") → "Invalid date"

ДЕТАЛИ:
Timezone: использовать локальный timezone пользователя
Время: формат 24h

НЕ ДЕЛАТЬ:
- Не используй moment.js
- Не добавляй i18n (только английский)

ФОРМАТ:
Один файл formatRelativeDate.ts с named export
```

## Паттерны для типичных задач

### Паттерн: Модификация существующего кода

```markdown
КОНТЕКСТ:
[технический стек]

ЗАДАЧА:
Добавить [новую функцию] в существующий [компонент/endpoint]

СУЩЕСТВУЮЩИЙ КОД:
```[язык]
[вставь текущий код]
```

ИЗМЕНЕНИЯ:
1. [Что добавить]
2. [Что изменить]
3. [Что удалить]

СОХРАНИТЬ:
- [Что не трогать]
- [Существующее поведение]
```

### Паттерн: Рефакторинг

```markdown
КОНТЕКСТ:
[технический стек]

ЗАДАЧА:
Рефакторинг [функции/компонента] для [цель: читаемость/производительность/переиспользование]

ТЕКУЩИЙ КОД:
```[язык]
[код для рефакторинга]
```

ЦЕЛЬ РЕФАКТОРИНГА:
- [Конкретная цель 1]
- [Конкретная цель 2]

ОГРАНИЧЕНИЯ:
- Сохранить тот же API (входы/выходы)
- Не менять функциональность
- [Другие ограничения]
```

### Паттерн: Исправление бага

```markdown
КОНТЕКСТ:
[технический стек]

ПРОБЛЕМА:
[Описание что не работает]

КОД С БАГОМ:
```[язык]
[код где баг]
```

ОЖИДАЕМОЕ ПОВЕДЕНИЕ:
[Что должно быть]

ТЕКУЩЕЕ ПОВЕДЕНИЕ:
[Что происходит сейчас]

STEPS TO REPRODUCE:
1. [Шаг 1]
2. [Шаг 2]
3. [Результат]

ДОПОЛНИТЕЛЬНО:
- Консоль ошибки: [если есть]
- Подозрение на причину: [если есть]
```

## Продвинутые техники промптинга

### Техника "Покажи пример"

Если хочешь специфичный стиль кода - покажи пример:

```markdown
СТИЛЬ КОДА:
Используй такой паттерн для error handling:

const result = await someFunction();
if (!result.success) {
  return { error: result.error };
}

НЕ используй try-catch, только result objects.
```

### Техника "Constraints first"

Сначала ограничения, потом требования:

```markdown
ОГРАНИЧЕНИЯ:
- Максимум 150 строк кода
- Без внешних библиотек кроме React
- Работает в IE11

ТРЕБОВАНИЯ:
[остальное]
```

### Техника "Negative examples"

Покажи что НЕ нужно:

```markdown
НЕ ДЕЛАЙ ТАК:
```typescript
const data = await fetch(...).then(r => r.json());
setData(data);
```

ДЕЛАЙ ТАК:
```typescript
const response = await fetch(...);
if (!response.ok) throw new Error();
const data = await response.json();
setData(data);
```
```

## Чек-лист финального промпта

Перед отправкой проверь:

- [ ] Указан технический стек
- [ ] Задача в 1 предложении
- [ ] Требования конкретные и измеримые
- [ ] Показана структура данных
- [ ] Указаны UI детали (если фронтенд)
- [ ] Есть раздел "НЕ ДЕЛАТЬ"
- [ ] Понятен формат ответа
- [ ] Промпт можно прочитать за 1 минуту
- [ ] Нет противоречий в требованиях
- [ ] Можно проверить результат

---

# Гайд 4: Постгенерация - Работа с результатом

## Шаг 1: Первичная проверка (30 секунд)

### Беглый просмотр

**Чек-лист за 30 секунд:**

- [ ] Правильная структура файлов?
- [ ] Используется правильный стек?
- [ ] Размер кода адекватный? (не 1000 строк вместо 100)
- [ ] Нет очевидных ошибок синтаксиса?
- [ ] Код визуально похож на то что просил?

**Красные флаги (не запускай, переспроси LLM):**

- Код в 2-3 раза больше ожидаемого
- Использует библиотеки которых нет в проекте
- Совсем другая структура чем просил
- Много закомментированного кода
- Используется устаревший синтаксис

### Что делать если красный флаг

**НЕ пытайся исправить сам** (если код большой).

Отправь новый промпт:

```markdown
Код слишком большой и использует библиотеки которых нет.

ТРЕБУЕТСЯ:
- Использовать только React встроенные хуки (useState, useEffect)
- Максимум 150 строк кода
- Без внешних библиотек кроме lucide-react

Перепиши компонент с этими ограничениями.
```

## Шаг 2: Запуск и тестирование (5-10 минут)

### Пошаговое тестирование

**1. Копирование и установка**

```bash
npm install
```

Если появляются ошибки недостающих зависимостей - реши сразу:
- Установи или
- Попроси LLM переписать без них

**2. Happy path testing**

Протестируй основной сценарий:

Фронтенд:
- Компонент рендерится?
- Основное действие работает?
- Данные отображаются?

Бэкенд:
- Endpoint отвечает?
- Возвращает правильный статус?
- Response формат правильный?

**3. Edge cases**

Протестируй граничные случаи:

- Пустые данные
- Очень длинные строки
- Специальные символы
- Отсутствующие поля

**4. Error handling**

Специально вызови ошибки:

- Невалидные данные
- Несуществующий ID
- Недоступный API
- Медленное соединение

### Лог проблем

Веди простой список что не работает:

```
❌ Кнопка Delete не показывает confirm
❌ Avatar не отображается если нет URL
✅ Email валидация работает
❌ Loading state не показывается
✅ Error message отображается
```

## Шаг 3: Анализ кода (5-10 минут)

### Читаемость

**Понимаешь ли ты код?**

Прочитай код от начала до конца:

- Понятны ли названия переменных?
- Логичная ли структура?
- Можешь ли объяснить что делает каждая функция?

**Если НЕ понимаешь > 20% кода - это проблема.**

Действия:
1. Попроси LLM объяснить непонятные части:
```
Объясни эту функцию:
```код функции```

Что она делает и почему написана так?
```

2. Попроси упростить:
```
Эта логика слишком сложная. Перепиши проще и понятнее.
Можно использовать больше переменных для ясности.
```

### Качество кода

**Чек-лист качества:**

- [ ] Нет дублирования кода
- [ ] Функции делают одно действие
- [ ] Нет магических чисел/строк
- [ ] Есть обработка ошибок
- [ ] Нет console.log в продакшен коде
- [ ] Нет закомментированного кода
- [ ] Нет TODO комментариев

**Если нашел проблемы:**

```markdown
ПРОБЛЕМЫ В КОДЕ:
1. [Описание проблемы 1]
2. [Описание проблемы 2]

Исправь эти проблемы, остальное оставь как есть.
```

### Соответствие требованиям

**Свери с оригинальным промптом:**

Требование | Реализовано | Проблема
-----------|-------------|----------
Email валидация | ✅ | -
Password >= 8 символов | ✅ | -
Confirm dialog на Delete | ❌ | Нет confirm
Loading state | ❌ | Не показывается

**Для нереализованных требований:**

```markdown
Код работает, но не хватает:
1. Confirm dialog при клике на Delete кнопку
2. Loading spinner во время API вызова

Добавь эти функции к существующему коду.

ТЕКУЩИЙ КОД:
```код```
```

## Шаг 4: Итеративное улучшение

### Стратегия инкрементальных изменений

**Правило: 1 промпт = 1 изменение**

❌ Плохо:
```
Исправь баг с Delete, добавь анимацию, улучши стили, и оптимизируй производительность
```

✅ Хорошо:
```
Промпт 1: Исправь баг с Delete confirm dialog
Промпт 2: Добавь fade-in анимацию при появлении
Промпт 3: Измени цвет кнопки на #3B82F6
```

### Приоритизация изменений

**1. Критичные (делаем сразу):**
- Не работает основная функция
- Ошибки в консоли
- Неправильные данные

**2. Важные (делаем следующими):**
- Отсутствует error handling
- Не хватает валидации
- UX проблемы (непонятный UI)

**3. Nice to have (делаем в конце):**
- Анимации
- Детали стилей
- Микро-оптимизации

### Техника "Изоляция изменения"

Когда просишь изменить код:

```markdown
ИЗМЕНИТЬ ТОЛЬКО:
Функцию handleDelete в строках 45-52

ОСТАВИТЬ КАК ЕСТЬ:
Весь остальной код без изменений

ИЗМЕНЕНИЕ:
Добавить window.confirm перед удалением:
if (!window.confirm('Delete user?')) return;
```

## Шаг 5: Рефакторинг после успешной работы

### Когда рефакторить

**Признаки что нужен рефакторинг:**

- Код работает, но сложно читать
- Много дублирования
- Функции больше 30 строк
- Глубокая вложенность (> 3 уровней)
- Сложные условия

**Но: не рефактори если нет времени.**
Работающий некрасивый код > неработающий красивый код.

### Пошаговый рефакторинг

**Шаг 1: Извлеки дублирование**

```markdown
В коде есть дублирование:

```typescript
[код с дублированием]
```

Вынеси общую логику в отдельную функцию.
```

**Шаг 2: Разбей большие функции**

```markdown
Функция handleSubmit слишком большая (80 строк).

Разбей на:
1. validateForm()
2. prepareData()
3. submitData()
4. handleResponse()

Главная функция должна только вызывать эти шаги.
```

**Шаг 3: Улучши naming**

```markdown
Переименуй для ясности:
- data → userData
- fn → handleUserClick  
- temp → validationResult
```

## Шаг 6: Документирование паттернов

### Создай библиотеку промптов

После успешной генерации - сохрани промпт:

```markdown
## Карточка пользователя

ПРОМПТ:
[твой успешный промпт]

РЕЗУЛЬТАТ:
✅ Работает с первого раза
✅ 150 строк кода
✅ Хорошая читаемость

ИЗМЕНЕНИЯ ПОСЛЕ:
- Добавил confirm на Delete
- Изменил цвет кнопки

LESSONS LEARNED:
- Обязательно указывать точные цвета
- "Confirm dialog" нужно явно запрашивать
```

### База знаний успешных паттернов

Заведи файл `llm-patterns.md`:

```markdown
# Успешные паттерны

## Формы

Всегда работает:
- React Hook Form + Zod
- Явно указывать все состояния (initial, filling, submitting, success, error)
- Примеры валидационных ошибок

## Таблицы

Работает лучше поэтапно:
1. Базовая таблица с данными
2. Сортировка
3. Фильтрация  
4. Пагинация

## API endpoints

Обязательно указывать:
- Все статус коды
- Примеры всех response (success + errors)
- Существующую Prisma схему
```

## Шаг 7: Подготовка следующего запроса

### Анализ текущего состояния

**Перед следующей задачей:**

1. **Что готово:**
   - Список завершенных компонентов
   - Что работает стабильно
   - Что можно использовать как зависимость

2. **Текущие проблемы:**
   - Известные баги (но некритичные)
   - Технический долг
   - Нерешенные вопросы

3. **Следующие шаги:**
   - Приоритетная задача
   - Зависимости (что нужно сначала)

### Контекст для следующего промпта

**Если новая задача зависит от предыдущей:**

```markdown
СУЩЕСТВУЮЩИЙ КОД:

У меня уже есть:
1. UserCard компонент (отображает карточку пользователя)
2. API endpoint GET /api/users/:id (получает данные пользователя)

НОВАЯ ЗАДАЧА:
Создать UserList компонент который использует UserCard

ИНТЕГРАЦИЯ:
- Импортировать UserCard из '../UserCard'
- Использовать тот же интерфейс User
- API endpoint для списка: GET /api/users
```

### Паттерн "Расширение функциональности"

**Когда добавляешь к существующему коду:**

```markdown
ТЕКУЩИЙ КОМПОНЕНТ:
```typescript
[вставь текущий код]
```

ДОБАВИТЬ:
[новая функциональность]

ТРЕБОВАНИЯ:
- Не ломать существующий функционал
- Использовать тот же стиль кода
- Сохранить текущий API (props)
```

## Шаг 8: Когда остановиться

### Признаки что задача выполнена

- [ ] Основная функциональность работает
- [ ] Все требования из промпта реализованы
- [ ] Нет критичных багов
- [ ] Ты понимаешь код
- [ ] Можешь объяснить как это работает
- [ ] Код можно поддерживать

### Признаки что перфекционизм

Остановись если:

- ✅ Работает, но хочешь "улучшить" без конкретной цели
- ✅ Переписываешь 3+ раз один и тот же код
- ✅ Оптимизируешь код без проблем производительности
- ✅ Меняешь стили "чтобы было красивее" без фидбека
- ✅ Рефакторишь код который никто не читает

**Правило 80/20:** 80% результата за 20% усилий - это нормально.

## Шаг 9: Сохранение результатов

### Коммит в git

**Структура коммита:**

```
feat: add UserCard component

- Display user avatar, name, email, role
- Edit and Delete buttons with callbacks
- Responsive design with Tailwind
- Generated with Claude LLM

AI-assisted: Claude generated initial code,
manually tested and fixed delete confirm dialog.
```

**Зачем указывать AI-assisted:**
- Честность перед командой
- Понимание что может потребовать проверки
- История решений

### Документация

**Добавь комментарии для будущего себя:**

```typescript
/**
 * UserCard component displays user information with edit/delete actions
 * 
 * Generated by: Claude LLM (2025-10-26)
 * Modified: Added confirm dialog for delete action
 * 
 * Known limitations:
 * - Avatar doesn't handle loading errors
 * - No retry logic for failed delete
 * 
 * TODO: Add skeleton loading state
 */
```

## Шаг 10: Обучение на ошибках

### Лог проблем и решений

Веди журнал:

```markdown
## 2025-10-26

ЗАДАЧА: UserCard component

ПРОБЛЕМЫ:
1. LLM не добавил confirm dialog
   РЕШЕНИЕ: Нужно явно писать "show confirm dialog"
   
2. Цвета не совпали
   РЕШЕНИЕ: Всегда указывать hex коды, не названия

3. Код был 300 строк вместо 150
   РЕШЕНИЕ: Добавил "максимум 150 строк" в ограничения

ВРЕМЯ: 25 минут (ожидал 15)
ИТЕРАЦИЙ: 3 (хотел с первого раза)

ВЫВОДЫ:
- Детальнее описывать UI интерактивность
- Указывать ограничения размера кода
```

### Обновление шаблонов

**После каждой успешной генерации:**

Обнови свой промпт-шаблон:

```markdown
ШАБЛОН: React Component v2.1

ОБНОВЛЕНИЯ:
+ Добавил секцию "Интерактивность" (работает лучше)
+ Всегда указываю hex коды цветов
+ Добавил ограничение "максимум X строк"

УДАЛИЛ:
- Раздел "архитектура" (для простых компонентов не нужен)
```

## Итоговый workflow

```
1. ПРОВЕРКА (30 сек)
   ↓
2. ЗАПУСК И ТЕСТ (5-10 мин)
   ↓
3. АНАЛИЗ КОДА (5-10 мин)
   ↓
   Все работает? → ДА → Коммит → Следующая задача
   ↓ НЕТ
4. ИТЕРАЦИЯ (1 изменение)
   ↓
   Вернуться к шагу 2
   ↓
   Больше 3 итераций? → СТОП → Переформулируй задачу
```

## Чек-лист работы с результатом

**После получения кода:**

- [ ] Быстрый просмотр (30 сек)
- [ ] Скопировал в проект
- [ ] Запустил и проверил happy path
- [ ] Протестировал edge cases
- [ ] Проверил error handling
- [ ] Прочитал и понял код
- [ ] Зафиксировал проблемы
- [ ] Сделал необходимые итерации
- [ ] Закоммитил с описанием
- [ ] Обновил документацию/шаблоны

**Если больше 3 итераций:**

- [ ] Остановился
- [ ] Проанализировал почему не получилось
- [ ] Переформулировал задачу
- [ ] Начал с нового промпта
